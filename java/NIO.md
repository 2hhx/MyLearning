## BIO NIO AIO

BIO

* **同步并阻塞**，服务器实现模式为⼀个连接⼀个线程，即客⼾端有连接请求时服务器端就需要启动⼀个线程进⾏处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
* BIO⽅式适⽤于连接数⽬⽐较⼩且固定的架构，这种⽅式对服务器资源要求⽐较⾼，并发局限于应⽤中，JDK1.4以前的唯⼀选择，但程序直观简单易理解。

NIO 

* **同步⾮阻塞**，服务器实现模式为⼀个请求⼀个线程，**即客⼾端发送的连接请求都会注册到多路复⽤器上，多路复⽤器轮询到连接有I/O请求时才启动⼀个线程进⾏处理**。
* NIO⽅式适⽤于**连接数⽬多且连接⽐较短**（轻操作）的架构，⽐如聊天服务器，并发局限于应⽤中，编程⽐较复杂，`JDK1.4`开始⽀持。

AIO

* **异步⾮阻塞**，服务器实现模式为⼀个有效请求⼀个线程，客⼾端的I/O请求都是由OS先完成了再通知服务器应⽤去启动线程进⾏处理。
* AIO⽅式使⽤于**连接数⽬多且连接⽐较⻓**（重操作）的架构，⽐如相册服务器，充分调⽤OS参与并发操作，编程⽐较复杂，`JDK1.7`开始⽀持。



## 同步与异步、阻塞与非阻塞

出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
1 老张把水壶放到火上，立等水开。（同步阻塞）
老张觉得自己有点傻
2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
3 老张把响水壶放到火上，立等水开。（异步阻塞）
老张觉得这样傻等意义不大
4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）
老张觉得自己聪明了。



所谓同步异步，只是对于水壶而言。
普通水壶，同步；响水壶，异步。
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。
同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。

所谓阻塞非阻塞，仅仅对于老张而言。
立等的老张，阻塞；看电视的老张，非阻塞。
情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。



**同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了。阻塞是烧开水的过程中，你不能干其他事情（即你被阻塞住了）；非阻塞是烧开水的过程里可以干其他事情。同步与异步说的是你获得水开了的方式不同。阻塞与非阻塞说的是你得到结果之前能不能干其他事情。两组概念描述的是不同的内容。**

*Java中的阻塞就是一个线程（比方说主线）进行IO操作，当没有完成的时候这个线程不可以进行其他的操作*



##  BIO：同步阻塞IO 

BlockingIO

代码地址： 

### 多个Socket单线程（只有一个管道流）

可以感受到阻塞（服务端只能有一个客户端连接）

- accept()这个方法是阻塞的
  
  - `Socket socket = server.accept();//这段代码会阻塞main这个主线程，服务器一直在监听8080端口`
 - IO操作是阻塞的
  
    - 单线程进行IO操作的时候要么读要么写
      - 读写流是阻塞的，因为在进行读写操作的时候用的是同一根管道流（同一个资源），读完再写或者写完了再读
    - 如果IO操作没有结束的话其他客户端是连接不上来的。
      - 在BIO中不可能只有一个客户端连接。

![image-20200424220539537](C:\Users\wwl\Documents\学习\MyLearning\java\images\image-20200424220539537.png) 

 

![image-20200424221149101](C:\Users\wwl\Documents\学习\MyLearning\java\images\image-20200424221149101.png)



### BIO解决IO阻塞：（多线程）多个Socket多线程：（每个线程都开启了一个管道流）

解决方案：main线程用来监听有客户端连接了，每建立一个socket连接开一个线程处理IO操作，开多个线程处理处理完就销毁

**多线程IO操作时，对于每个线程IO还是阻塞的，但是对全局所有的线程就不是阻塞的了**

<img src="C:\Users\wwl\Documents\学习\MyLearning\java\images\image-20200424222916291.png" alt="image-20200424222916291" style="zoom:50%;" />

### BIO的问题

- 客户端和服务端交互的本质时数据的交流（IO），socket连接操作只是为了去得到传输的IO
- 希望有socket连接的时候不要开启新线程，等到有IO操作了再开启线程
- 在BIO中，线程池已经可以解决这个问题
- 用线程池来处理IO操作，进行IO操作的时候才用线程池开启线程。每次从线程池中拿一个线程去执行任务。
  - 线程池在进行IO操作的时候，分配一个线程给你去执行run任务
  - 我一开始就在线程池中放60个线程去处理IO操作，线程复用，避免浪费
  - 线程池只给你分配了60个线程来处理，如果连接超过60个时就需要等待
  - 固定数目的线程减轻了服务器的压力

<img src="C:\Users\wwl\Documents\学习\MyLearning\java\images\image-20200424230141370.png" alt="image-20200424230141370" style="zoom:50%;" />

### 线程池的管理方式的问题（不适用高并发）

如果只有60个线程池，但是一下子来了600个请求，就需要等待（线程还是被阻塞了）。

### BIO存在的问题（综合）

1. 每一个socket连接，服务器都会立刻开启一个线程处理----》连接不开启线程，IO操作再 开启线程
2. 每个IO操作完成之后，线程就会销毁----》好不容易开启的IO管道流不能轻易销毁

## NIO：NewIO/Non-BlockingIO

**NIO：同步非阻塞IO ---- 客户端发送请求后还是会被阻塞。**

- 在标准IO中，我们使用字节流或者字符流来操作IO，在NIO中，使用channels和buffers。数据总是从channel中读取存到buffer，或从buffer中写入到channel。
- 即使是单线程也可以实现非阻塞读写（BIO需要开很多线程才能实现全局的非阻塞）
-  selectors：用于监视多通道的事件。因此单线程就可以监视多个客户端的Connections（Channels）

**解决BIO的问题：**

- 在服务端有一个主线程（main），负责记录客户端的连接操作和所处状态（不马上处理），只有当状态变成read或write时才会开启线程
  - ACCEPT：刚建立连接状态
  - 进行IO操作时：
    - READ：读状态
    - WRITE：写状态
- 在客户端与服务端之间建立多个传输数据的通道
- 但是进行普通流进行IO操做的时候还是会阻塞的，因为只有一个管道，不能同时进行读写
- 非阻塞IO需要可以同时读写不阻塞
- Buffer(缓冲区)：实现读写的同步非阻塞

![image-20200424235003595](C:\Users\wwl\Documents\学习\MyLearning\java\images\image-20200424235003595.png)

### BIO的重要组成部分

#### Buffer

缓冲区（Buffer）

*  缓冲区（Buffer）：**一个用于特定基本数据类型的容器，就像一个数组，可以保存多个相同类型的数据**

*  Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，**数据是从通道读入缓冲区，从缓冲区写入通道中的**。

#### Channel

Channel 表示 IO 源与目标打开的连接。
Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互。

- Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。
- Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。

（1）Socket 和ServerSocke 是一对  他们是java.net下面实现socket通信的类
   (2)  SocketChannel 和ServerSocketChannel是一对   他们是java.nio下面实现通信的类 支持异步通信
   (3)服务器必须先建立ServerSocket或者ServerSocketChannel 来等待客户端的连接
 （4）客户端必须建立相对应的Socket或者SocketChannel来与服务器建立连接
 （5）服务器接受到客户端的连接时，再生成一个Socket或者SocketChannel与此客户端通信

#### Selector

用于监视多通道的事件。因此单线程就可以监视多个客户端的Connections（Channels）

![image-20200425010405523](C:\Users\wwl\Documents\学习\MyLearning\java\images\image-20200425010405523.png)


## Netty框架

封装了NIO



