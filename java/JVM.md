# JVM
## Java内存区域
### 线程共享
- 堆(存放对象实例,几乎所有的对象都在这里分配内存) 
- 方法区(类变量、类方法、常量池、类信息)
```
    类信息：
    一 这个类型的完整有效名 
    二 这个类型直接父类的完整有效名(除非这个类型是interface或是java.lang.Object，两种情况下都没有父类) 
    三 这个类型的修饰符(public,abstract, final的某个子集) 
    四 这个类型直接接口的一个有序列表 
```
### 线程独占
1. 程序计数器（字节码执行到第几行了）
2. 虚拟机栈(java方法：为每个执行的方法开辟栈帧，描述方法的出入栈)
3. 本地方法栈（服务的对象是JVM执行的native方法）

## 类的生命周期

1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

### 类的加载过程
1. 加载: 查找并加载类的二进制数据(Class文件)
    - 把类的信息放到方法区
    - 堆：Class文件对应的类实例
2. 验证：确保加载的类信息是正确的 
3. 准备：为类的静态变量进行初始化，分配空间并赋予初始值（int=0，引用类型=null）
4. 解析：将符号引用转换为直接引用：如下，a只是一个符号，要将该符号指向一个引用地址
```
Animal a = new Cat();
a.sleep();
a = new Dog();
 a.sleep();
a = new Tiger();
 a.sleep();
```
5. 初始化：JVM堆类进行初始化，对静态变量赋予正确值（在准备阶段只是开辟空间并赋予初始值）
    - 静态代码块用于类的初始化
### 类加载器
1. APPClassLoader(加载类路径下面的类)
2. ExtClassLoader（APPClassLoader.getParent，加载JDK/JRE/LIB下的javax.类）
3. BootStrapClassLoader（C语言写的，ExtClassLoader.getParent加载JDK/JRE/LIB下的java.类）
4. 用户自定义类加载器

双亲委派模型：两个过程，一次向上，一次向下。一个类加载器收到了加载请求，首先自己不加载这个类而是把请求委托给他的父亲，依次向上到顶层，父加载器没加载到这个类才会向下委派子加载器加载该类。

## 垃圾回收机制

堆被分解为较小的三个部分。具体分为：新生代、老年代、持久代。

![img](https://upload-images.jianshu.io/upload_images/302647-bc51a1dc8f905636..png)

1. 绝大部分新生成的对象都放在Eden区，当Eden区将满，JVM会因申请不到内存，而触发Young GC ,进行Eden区+有对象的Survivor区(设为S0区)垃圾回收，把存活的对象用复制算法拷贝到一个空的Survivor(S1)中，此时Eden区被清空，另外一个Survivor S0也为空。下次触发Young GC回收Eden+S0，将存活对象拷贝到S1中。新生代垃圾回收简单、粗暴、高效。
2. 若发现Survivor区满了，则将这些对象拷贝到old区或者Survivor没满但某些对象足够Old,也拷贝到Old区(每次Young GC都会使Survivor区存活对象值+1，直到阈值)。 3.Old区也会进行垃圾收集(Young GC),发生一次 Major GC 至少伴随一次Young GC，一般比Young GC慢十倍以上。
3. **JVM在Old区申请不到内存，会进行Full GC**。**Old区使用一般采用Concurrent-Mark–Sweep**策略回收内存。

### 什么样的对象是垃圾
- 引用计数法（被引用次数为0视为垃圾，但存在循环引用问题）
- 可达性分析法（什么是GC ROOT）
    - 虚拟机栈中引用的对象
    - 方法区中的常量和静态变量
    - 本地方法栈中的对象
```
每个中括号代表一个对象，GC ROOT是不会被回收的，如果被它引用(可达，就不会被回收)，如果像右边部分游离在之外不可达GC ROOT，计算互相之间有引用也会被回收  
----------------------[GC ROOT]--------------------
                    /
                 []         []
               /   \          \
             []     []         []
----------------------------------------------------             
```

### 垃圾回收算法

GC算法Garbage Collection

- 标记-清除（把要回收的垃圾标记，再清楚--会产生内存碎片）
- 复制（有一半空间被浪费，将要回收的垃圾标记，将一半内存中不是垃圾的对象复制到空的内存中，再将原来耗尽的内存清空）
- 标记-整理（将垃圾标记，进行整理放到不回收的内存后面，空的内存之前，再将垃圾清除，增加空的内存）【相当于内存整理了】
- 分代回收算法（也是基于前面的算法）
    - 新生代（存活时间很短）
    - 老年代（从新生代复制过来的） 

### CMS回收器

CMS收集器仅作用于**老年代**的收集，是基于`标记-清除算法`的，它的运作过程分为4个步骤：

- 初始标记（CMS initial mark）【STW】
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）【STW】
- 并发清除（CMS concurrent sweep）

CMS回收器（concurrent-mark-sweep）：这个算法使用了**多个线程**（concurrent）来**扫描堆并标记**（mark）那些不再使用的可以**回收(sweep)的对象**。这个算法在两种情况下会进入一个**”stop the world”**的模式：

- 当进行根对象的初始标记的时候 （老生代中线程入口点或静态变量可达的那些对象）
- 当这个算法在并发运行的时候应用程序改变了堆的状态使得它不得不回去再次确认自己标记的对象都是正确的。

问题：

在回收新生代及年老代时出现了竞争条件的情况（后台线程还未扫描完无用对象前堆就已经用光）。如果回收器需要将年轻的对象提升到年老代中，而这个时候年老代没有多余的空间了，它就只能先进行一次STW(Stop The World)的full GC了——这种情况正是CMS所希望避免的

假设你的**堆小于4G**，而你**又希望分配更多的CPU资源以避免应用暂停**，那么这就是你要选择的回收器。

然而，如果**堆大于4G**的话，——**G1回收器。**

### G1回收器

但是G1同时回收老年代和年轻代，而CMS只能回收老年代，需要配合一个年轻代收集器。另外G1的分代更多是逻辑上的概念，G1将内存分成多个等大小的region，`Eden`/ `Survivor`/`Old`分别是一部分region的逻辑集合，物理上内存地址并不连续。

![img](https://upload-images.jianshu.io/upload_images/1722445-20e287ca91b9096f.png?imageMogr2/auto-orient/strip|imageView2/2/w/739)

**G1重新定义了堆空间，打破了原有的分代模型**，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点

G1（ Garbage first）：G1回收器将堆分为多个区域，大小从1MB到32MB不等，并使用多个后台线程来扫描它们。G1回收器会优先扫描那些包含垃圾最多的区域，这正是它的名字的由来（Garbage first）。

这一策略**减少了后台线程还未扫描完无用对象前堆就已经用光的可能性**，而那种情况回收器就必须得暂停应用，这就会导致STW回收。

- G1从整体来看是基于**标记-整理算法**实现的收集器，G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存
- 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了。