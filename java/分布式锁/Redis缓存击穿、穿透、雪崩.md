#  **缓存击穿** Cache breakdown

**缓存击穿**：缓存中没有，数据库中有，**发生在高并发环境下。**

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

1. 构建缓存采取异步策略，从而使热点数据永不过期

   ![](https://img2018.cnblogs.com/blog/1558776/201906/1558776-20190623161010790-1691300786.png)

2. 使用互斥锁(redis或zookeeper分布式锁)。只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了。

   **至于锁的类型，单机环境用并发包的Lock类型就行，集群环境则使用分布式锁( redis的setnx)**

   ![](https://img2018.cnblogs.com/blog/1558776/201906/1558776-20190623160346016-1677811775.png)

# 缓存穿透Cache penetration

**缓存穿透**：缓存中没有，数据库也没有，返回的空对象没有缓存因此每次这种key的请求都会到达数据库，数据库可能会崩。

1. 数据库中没有这个key，`redis`缓存空对象并设置较短过期时间，避免空对象占满 `redis`缓存
2. 使用**布隆过滤器**，将数据库中一定不存在的对象过滤掉
3. 如果这种无效请求重复率很高(一个key)，使用第一种；如果重复率比较低，但是有大量的key(比如uuid)，使用布隆过滤器可以过滤大部分无效请求。

# 缓存雪崩

**缓存雪崩**：在某一个时间段，缓存集中失效或者redis服务器崩了，所有对这些数据的请求直接命中DB

1. 使用redis集群
2. **限流降级**，减少一次处理的请求。在缓存失效后，通过**加锁或者队列**来控制读数据库写缓存的线程数量。
3. 解决方法是不同类型的对象**设置不同的过期时间**，也可以在过期时间中加入随机因子，尽量分散缓存过期的时间段。