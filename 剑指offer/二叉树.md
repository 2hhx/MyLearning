### 二叉树的数据结构以及前序、中序、后续遍历

```java
import java.util.ArrayList;

class BinaryTreeNode {
    char value;
    BinaryTreeNode left;
    BinaryTreeNode right;
    BinaryTreeNode(char value){
        this.value=value;
    }
}

public class binaryTree {
    ArrayList<Character> list = new ArrayList<>();
    //前序遍历
    private ArrayList<Character> preOrderTraver(BinaryTreeNode t){

        if(t!=null) {
            list.add(t.value);
            preOrderTraver(t.left);
            preOrderTraver(t.right);
        }
        return list;
    }
    //中序遍历
    private ArrayList<Character> midOrderTraver(BinaryTreeNode t){
        if(t!=null) {
            midOrderTraver(t.left);
            list.add(t.value);
            midOrderTraver(t.right);
        }
        return list;
    }
	//后序遍历
    private ArrayList<Character> postOrderTraver(BinaryTreeNode t){
        if(t!=null) {
            postOrderTraver(t.left);
            postOrderTraver(t.right);
            list.add(t.value);
        }
        return list;
    }

    public static void main(String[] args) {

        char[] a = {'a','b','c','d','e','f','g','h','i'};
        BinaryTreeNode[] b = new BinaryTreeNode[a.length];
        for (int i = 0;i < a.length; i++){
            b[i] = new BinaryTreeNode(a[i]);
        }

        b[0].left = b[1];
        b[0].right = b[2];
        b[1].left = b[3];
        b[1].right = b[4];
        b[2].left = b[5];
        b[2].right = b[6];
        b[4].left = b[7];
        b[4].right = b[8];

        System.out.println("========This is preOrderTraver========");
        for( char x:new binaryTree().preOrderTraver(b[0])){
            System.out.println(x);
        }

        System.out.println("========This is midOrderTraver========");
        for( char x:new binaryTree().midOrderTraver(b[0])){

            System.out.println(x);
        }

        System.out.println("========This is PostOrderTraver========");
        for( char x:new binaryTree().postOrderTraver(b[0])){

            System.out.println(x);
        }
    }
}
```
### 二叉树的下一个节点

不管是找前序、中序还是后续遍历的下一个节点，只要有了遍历的集合，再查表一次就行了。

```java
import java.util.ArrayList;

public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
    TreeLinkNode(){

    }
    ArrayList<TreeLinkNode> list = new ArrayList<>();
    private void midOrderTraver(TreeLinkNode t){
        if(t!=null) {
            midOrderTraver(t.left);
            list.add(t);
            midOrderTraver(t.right);
        }
    }
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        TreeLinkNode curNode = new TreeLinkNode();
        curNode = pNode;
        while (pNode.next!=null){
            pNode=pNode.next;
        }
        midOrderTraver(pNode);
        for(TreeLinkNode t:list){
            if (t==curNode){
                System.out.println(list.indexOf(t));
                if (list.indexOf(t)==list.size()-1) return null;
                return list.get(list.indexOf(t)+1);
            }
        }
        return pNode;
    }

    public static void main(String[] args) {
        char[] a = {'a','b','c','d','e','f','g','h','i'};
        TreeLinkNode[] b = new TreeLinkNode[a.length];
        for (int i = 0;i < a.length; i++){
            b[i] = new TreeLinkNode(a[i]);
        }

        b[0].left = b[1];
        b[0].right = b[2];
        b[1].left = b[3];
        b[1].right = b[4];
        b[1].next = b[0];
        b[2].left = b[5];
        b[2].right = b[6];
        b[2].next = b[0];
        b[3].next = b[1];
        b[4].left = b[7];
        b[4].right = b[8];
        b[4].next = b[1];
        b[5].next = b[2];
        b[6].next = b[2];
        b[7].next = b[4];
        b[8].next = b[4];
        System.out.println(new TreeLinkNode().GetNext(b[6]).val);
    }
}
```

### 二叉树的宽度优先遍历



```java
   private ArrayList<Character> BFS(BinaryTreeNode root){
        ArrayList<Character> lists=new ArrayList<Character>();
        if(root==null)
            return lists;
        Queue<BinaryTreeNode> queue=new LinkedList<BinaryTreeNode>();
       //把起始点放入对列
        queue.offer(root);
       //重复以下的步骤知道对列为空为止
        while (!queue.isEmpty()){
            // 从队列中取出对列头
           BinaryTreeNode node = queue.poll();
            //将其放入已访问列表
           lists.add(node.value);
            //找到与队列头连接的点，将其放入queue中
           if(node.left!=null)
               queue.offer(node.left);
           if(node.right!=null)
               queue.offer(node.right);
        }
        return lists;
    }
```

